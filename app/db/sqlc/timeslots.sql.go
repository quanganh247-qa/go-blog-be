// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: timeslots.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllTimeSlots = `-- name: GetAllTimeSlots :many
SELECT 
    ts.doctor_id ,
    ts.start_time,
    ts.end_time
FROM 
    TimeSlots ts
JOIN 
    Doctors d ON ts.doctor_id = d.id
WHERE 
    d.id = $1  -- Replace $1 with the doctor's ID you are querying for
    AND ts.day::date = $2
`

type GetAllTimeSlotsParams struct {
	ID  int64       `json:"id"`
	Day pgtype.Date `json:"day"`
}

type GetAllTimeSlotsRow struct {
	DoctorID  int64            `json:"doctor_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetAllTimeSlots(ctx context.Context, arg GetAllTimeSlotsParams) ([]GetAllTimeSlotsRow, error) {
	rows, err := q.db.Query(ctx, getAllTimeSlots, arg.ID, arg.Day)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTimeSlotsRow{}
	for rows.Next() {
		var i GetAllTimeSlotsRow
		if err := rows.Scan(&i.DoctorID, &i.StartTime, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeslotsAvailable = `-- name: GetTimeslotsAvailable :many
SELECT 
    ts.doctor_id ,
    ts.start_time,
    ts.end_time
FROM 
    TimeSlots ts
JOIN 
    Doctors d ON ts.doctor_id = d.id
WHERE 
    d.id = $1  -- Replace $1 with the doctor's ID you are querying for
    AND ts.day::date = $2  -- Replace $2 with the specific date (YYYY-MM-DD)
    AND ts.is_active = true
`

type GetTimeslotsAvailableParams struct {
	ID  int64       `json:"id"`
	Day pgtype.Date `json:"day"`
}

type GetTimeslotsAvailableRow struct {
	DoctorID  int64            `json:"doctor_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetTimeslotsAvailable(ctx context.Context, arg GetTimeslotsAvailableParams) ([]GetTimeslotsAvailableRow, error) {
	rows, err := q.db.Query(ctx, getTimeslotsAvailable, arg.ID, arg.Day)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimeslotsAvailableRow{}
	for rows.Next() {
		var i GetTimeslotsAvailableRow
		if err := rows.Scan(&i.DoctorID, &i.StartTime, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTimeslot = `-- name: InsertTimeslot :one
INSERT INTO Timeslots (
    doctor_id,
    start_time,
    end_time,
    day
) VALUES (
    $1, $2, $3, now()
) RETURNING id, doctor_id, start_time, end_time, is_active, day
`

type InsertTimeslotParams struct {
	DoctorID  int64            `json:"doctor_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) InsertTimeslot(ctx context.Context, arg InsertTimeslotParams) (Timeslot, error) {
	row := q.db.QueryRow(ctx, insertTimeslot, arg.DoctorID, arg.StartTime, arg.EndTime)
	var i Timeslot
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.Day,
	)
	return i, err
}

const updateDoctorAvailable = `-- name: UpdateDoctorAvailable :exec

UPDATE TimeSlots
SET is_active = $1
WHERE id = $2
`

type UpdateDoctorAvailableParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	ID       int64       `json:"id"`
}

// Replace $2 with the specific date (YYYY-MM-DD)
func (q *Queries) UpdateDoctorAvailable(ctx context.Context, arg UpdateDoctorAvailableParams) error {
	_, err := q.db.Exec(ctx, updateDoctorAvailable, arg.IsActive, arg.ID)
	return err
}
